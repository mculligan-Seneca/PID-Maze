#pragma config(StandardModel, "RVW SQUAREBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//mitchell Culligan
//161293170
//maze solver
#define WHEEL_RADIUS 2.8 //in cm
#define ENCODECNT 720
#define WIDTH 23
#define LENGTH 33
#define WHEEL_COUNT 2 //number of wheels on each side
int getEncoderCount(float distance,int encoderCnt,float radius){
		float circ = 2*PI*radius;
		float distProd= distance*encoderCnt;


		return (distProd/circ);

}
void moveForward(float distance, int speed){
		int encCount=getEncoderCount(distance,ENCODECNT,WHEEL_RADIUS);
		resetSensor(leftEncoder);
		resetSensor(rightEncoder);
		//	waitUntilMotorStop(rightMotor);
		//waitUntilMotorStop(leftMotor);
		while(SensorValue[leftEncoder]<encCount){
			motor[leftMotor]=speed;
			motor[rightMotor]=speed;
		}
		motor[leftMotor]=0;
		motor[rightMotor]=0;

}

float getRadius(float length, float width){
	float lSqrd = (length*length);
	float wSqrd = (width*width);
	return sqrt(lSqrd+wSqrd)/2;
}
float getRadFromDeg(int degreeVar, int encoderCnt){
	float rad = getRadius(LENGTH,WIDTH);
	float dist = (2*rad*PI*degreeVar)/(ENCODECNT);//get distance of circle
	return dist;
}
void rotateLeft(int degreeVar,int speed){
		//((rad*degreeVar)/(WHEEL_RADIUS));
    float dist = getRadFromDeg(degreeVar,ENCODECNT);
	int encodeCnt = getEncoderCount(dist,ENCODECNT,WHEEL_RADIUS)/1.75;//divide by 2 since both motors going
	//divide by two cause moving left and right motor
	resetSensor(rightEncoder);
	resetSensor(leftEncoder);
	while(SensorValue[rightEncoder]<encodeCnt){
			motor[rightMotor]=speed;
			motor[leftMotor]=-speed;
		}

	//turnLeft(rot,rotations,speed);
	motor[rightMotor]=0;
	motor[leftMotor]=0;
}
void rotateRight(int degreeVar,int speed){
	//((rad*degreeVar)/(WHEEL_RADIUS));
	float dist = getRadFromDeg(degreeVar,ENCODECNT);
	int encodeCnt = getEncoderCount(dist,ENCODECNT,WHEEL_RADIUS)/1.75;//divide by 2 since both motors going
	//divide by two cause moving left and right motor
	resetSensor(rightEncoder);
	resetSensor(leftEncoder);
	while(SensorValue[leftEncoder]<encodeCnt){
		motor[leftMotor]=speed;
		motor[rightMotor]=-speed;
		}
	//turnLeft(rot,rotations,speed);
	motor[rightMotor]=0;
	motor[leftMotor]=0;
}

float calcError(float measured,float expected){
		return (measured-expected)/expected;
}
//distance is the distance to stay away from wall
void followWall(float distance,int speed){
		float gain =0.5;
		float dist=SensorValue[sonarSensor];
		float err=0.0;
		while(true){
			err=fabs(1-calcError(dist,distance));
			if(dist<distance){
					rotateLeft(30*err,speed);
			}else if(dist>distance){
					rotateRight(30*err,speed);
			}
				moveForward((1+err)*gain,speed);
			dist=SensorValue[sonarSensor];
		}

}

void absoluteDeg(float currentDegs,float degToTurn,int speed){

		if((currentDegs+degToTurn)>0)
			rotateLeft(degToTurn,speed);
	  else
	   rotateRight(degToTurn,speed);



}

task main()
{
	float radi= getRadius(LENGTH,WIDTH);
	float dist=SensorValue[sonarSensor];
	int speed=63;

	float err=0.0;
	float prevErr=0.0;
	float integral=0.0;
	float kp=0.18;//0.2
	float ki=0.15;//0.05  ALMOST!!!
	float kd=0.28;//0.28
	float threshold=55;
	float goal=0.0;//goal direction is straight ahead
	float direction=0.0;
	float der=0.0;
	float pvm=0.0;
	float degs=0.0;
//	moveForward(radi,speed);

	while(true){


		dist=SensorValue[sonarSensor];

		err=(threshold-dist);
		integral+=err;

		der=err-der;
		pvm = (kp*err)+(ki*integral)+(kd*der);
		direction+=pvm;
		//direction+=pvm;
		if(pvm<0)
			rotateRight(abs(pvm),speed);
		else
			rotateLeft(abs(pvm),speed);
        
		moveForward(1,speed);
		der=err;
	}

/*
	while(true){

		moveForward(1,speed);
		prevDist=dist;
		dist=SensorValue[sonarSensor];
		err=calcError(dist,threshold);
		der=(dist-prevDist);

		degs=(gain*(1-err))+der+errSum;
		degs=abs(degs);
		if(errSum<0){

			rotateLeft(degs,speed);
		}else{
			rotateRight(degs,speed);
		}

			errSum+=err+der;




	}*/
	//	followWall(radi,speed);
}
