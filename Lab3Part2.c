#pragma config(StandardModel, "RVW CLAWBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Mitchell Culligan Id 161293170
//lab 3 part 2
#define WHEEL_RADIUS 4.7//in cm
#define ENCODECNT 720
#define WIDTH 31
#define LENGTH 47
#define WHEEL_COUNT 2 //number of wheels on each side

struct ObjPosition{
	float x;
	float y;
	float bearing;
};

//returns the number of pulses an encoder must count to complete a certain distance
int getEncoderCount(float distance,int encoderCnt,float radius){
	float circ = 2*PI*radius;
	float distProd= distance*encoderCnt;


	return (distProd/circ);

}

//distance is in cm
void moveForward(float distance, int speed){
	int encCount=getEncoderCount(distance,ENCODECNT,WHEEL_RADIUS);



	resetSensor(leftEncoder);
	resetSensor(rightEncoder);

	//	waitUntilMotorStop(rightMotor);
	//waitUntilMotorStop(leftMotor);

	while(SensorValue[leftEncoder]<encCount){
		motor[leftMotor]=speed;
		motor[rightMotor]=speed;

	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;


}

float getRadius(float length, float width){
	float lSqrd = (length*length);
	float wSqrd = (width*width);
	return sqrt(lSqrd+wSqrd)/2;
}
void rotateLeft(int degreeVar,int speed){
	//((rad*degreeVar)/(WHEEL_RADIUS));
	float rad = getRadius(LENGTH,WIDTH);
	float dist = (2*rad*PI*degreeVar)/(ENCODECNT);//get distance of circle
	int encodeCnt = getEncoderCount(dist,ENCODECNT,WHEEL_RADIUS)/2;///2;//divide by 2 since both motors going
	//divide by two cause moving left and right motor
	resetSensor(rightEncoder);
	resetSensor(leftEncoder);
	while(SensorValue[rightEncoder]<encodeCnt){
		motor[rightMotor]=speed;
		motor[leftMotor]=-speed;
	}


	//turnLeft(rot,rotations,speed);



	motor[rightMotor]=0;
	motor[leftMotor]=0;
}
void rotateRight(int degreeVar,int speed){

	//((rad*degreeVar)/(WHEEL_RADIUS));
	float rad = getRadius(LENGTH,WIDTH);
	float dist = (2*rad*PI*degreeVar)/(ENCODECNT);//get distance of circle
	int encodeCnt = getEncoderCount(dist,ENCODECNT,WHEEL_RADIUS)/2;//2;//divide by 2 since both motors going
	//divide by two cause moving left and right motor
	resetSensor(rightEncoder);
	resetSensor(leftEncoder);
	while(SensorValue[leftEncoder]<encodeCnt){
		motor[leftMotor]=speed;
		motor[rightMotor]=-speed;

	}


	//turnLeft(rot,rotations,speed);



	motor[rightMotor]=0;
	motor[leftMotor]=0;


}

void calcDistanceMoved(ObjPosition* obj,float distance){
	obj->x+=distance*cosDegrees(obj->bearing);
	obj->y+=distance*sinDegrees(obj->bearing);
}
void rotateRobot(ObjPosition* robot, float degreesToTurn,int speed){
	if(degreesToTurn<0)
		rotateRight(abs(degreesToTurn),speed);
	else
		rotateLeft(degreesToTurn,speed);

	robot->bearing=(robot->bearing+degreesToTurn+360)%360;
}

void moveRobot(ObjPosition* robot,float distance, int speed){
	moveForward(distance,speed);
	calcDistanceMoved(robot,distance);
}





float q=0.0;
void detectObject(ObjPosition* robot,int threshold,int speed){

	float err=0;
	float integral=0.0;
	float der=0.0;
	float kp=0.15;
	float ki=0.05;
	float kd=0.10;
	float distanceMoved=1;
	float dist=SensorValue[sonarSensor];
	float prevDist=SensorValue[sonarSensor]-distanceMoved;
	float degs=0.0;
	float o=0.0;

	while(dist>threshold){




		err=dist-prevDist+distanceMoved;

		integral+=err;
		der=err-der;
		degs=(kp*err)+(ki*integral)+(kd*der);

		rotateRobot(robot,degs,speed);
		moveRobot(robot,distanceMoved,speed);
		prevDist=dist;
		dist=SensorValue[sonarSensor];


		der=err;
		//	wait1Msec(2000);
		/*
		prevDist=dist;



		err=(dist+distanceMoved)-prevDist;
		integral+=err;
		der=err-der;
		degs=(kp*err)+(ki*integral)+(kd*der);
		rotateRobot(robot,degs,speed);
		moveRobot(robot,distanceMoved,speed);
		der=err;
		*/
	}

}







float findBearing(const ObjPosition m, const ObjPosition x){
	float bearing=0.0;
	float o = m.y-x.y;
	float a = m.x-x.x;

	bearing= radiansToDegrees(atan(o/a))-x.bearing;

	return bearing;
}

float findRange(ObjPosition m, ObjPosition x){
	float range=0.0;
	float a=pow((m.x-x.x),2);
	float b=pow((m.y-x.y),2);
	range=sqrt(a+b);
	return range;

}

void findStation(ObjPosition* station, ObjPosition* robot,int speed){

	float degs=findBearing(*station,*robot);

	//robot->bearing=(robot->bearing+degs)%360;
	float distance=0.0;
	rotateRobot(robot,degs,speed);
	distance=findRange(*station,*robot);
	moveRobot(robot,distance,speed);
}
ObjPosition robot;
task main()
{
	struct ObjPosition secondStation;
	secondStation.x=160;
	secondStation.y=160;
	secondStation.bearing=135;
	struct ObjPosition firstStation;
	firstStation.x=1;
	firstStation.y=160;
	firstStation.bearing=180;


	//ObjPosition robot;
	float distance=1;
	int speed=63;
	float degs=0.0;
	robot.x=11;
	robot.y=21;
	robot.bearing=0;
	ObjPosition stations[2];
	stations[0]=firstStation;
	stations[1]=secondStation;
	int index=0;
	int threshold=15;



//	moveRobot(&robot,15,speed);
	//rotateRobot(&robot,13,speed);
//	moveRobot(&robot,4,speed);

//	findStation(&firstStation,&robot,speed);

	//detectObject(&robot,threshold,speed);

	while(true){
	detectObject(&robot,threshold,speed);

	if(!index)
		findStation(&firstStation,&robot,speed);
	else
		findStation(&secondStation,&robot,speed);
	index=!index;

	rotateRobot(&robot,90,speed);

	}


	//rotateLeft(90,speed);

	/*
	moveForward(100,speed);
	calcDistanceMoved(&robot,100);
	degs=90;
	rotateLeft(degs,speed);
	robot.bearing=(robot.bearing+degs)%360;
	moveForward(50,speed);
	calcDistanceMoved(&robot,50);
	*/


	//	detectObject(15,speed);


}
